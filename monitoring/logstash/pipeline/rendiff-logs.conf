input {
  # Beats input for Filebeat
  beats {
    port => 5044
  }
  
  # TCP input for direct log shipping
  tcp {
    port => 5000
    codec => json_lines
  }
  
  # UDP input for high-volume logs
  udp {
    port => 5000
    codec => json_lines
  }
}

filter {
  # Parse container logs from Docker
  if [container] {
    mutate {
      add_field => { "[@metadata][index_prefix]" => "rendiff-docker" }
    }
    
    # Extract service name from container name
    if [container][name] {
      grok {
        match => { "[container][name]" => "^/?(?<service_name>[^-]+)" }
      }
    }
  }

  # Parse Rendiff API logs (structured JSON)
  if [fields][service] == "rendiff-api" or [log][file][path] =~ /rendiff.*\.log/ {
    mutate {
      add_field => { "[@metadata][index_prefix]" => "rendiff-api" }
    }
    
    # Parse JSON log messages
    if [message] =~ /^\{.*\}$/ {
      json {
        source => "message"
        target => "app_log"
      }
      
      # Extract log level
      if [app_log][level] {
        mutate {
          add_field => { "log_level" => "%{[app_log][level]}" }
        }
      }
      
      # Extract timestamp
      if [app_log][timestamp] {
        date {
          match => [ "[app_log][timestamp]", "ISO8601" ]
        }
      }
      
      # Extract job ID for correlation
      if [app_log][job_id] {
        mutate {
          add_field => { "job_id" => "%{[app_log][job_id]}" }
        }
      }
      
      # Extract user ID for correlation
      if [app_log][user_id] {
        mutate {
          add_field => { "user_id" => "%{[app_log][user_id]}" }
        }
      }
      
      # Extract API endpoint
      if [app_log][path] {
        mutate {
          add_field => { "api_endpoint" => "%{[app_log][path]}" }
        }
      }
      
      # Extract error information
      if [app_log][error] {
        mutate {
          add_field => { "error_message" => "%{[app_log][error]}" }
          add_tag => [ "error" ]
        }
      }
    }
  }

  # Parse Traefik access logs
  if [fields][service] == "traefik" or [log][file][path] =~ /traefik.*access\.log/ {
    mutate {
      add_field => { "[@metadata][index_prefix]" => "rendiff-traefik" }
    }
    
    # Parse JSON access logs
    if [message] =~ /^\{.*\}$/ {
      json {
        source => "message"
        target => "traefik_log"
      }
      
      # Extract common fields
      if [traefik_log][ClientAddr] {
        mutate {
          add_field => { "client_ip" => "%{[traefik_log][ClientAddr]}" }
        }
        
        # Extract IP without port
        grok {
          match => { "client_ip" => "^(?<client_ip_clean>[^:]+)" }
          overwrite => [ "client_ip" ]
        }
      }
      
      if [traefik_log][RequestMethod] {
        mutate {
          add_field => { "http_method" => "%{[traefik_log][RequestMethod]}" }
        }
      }
      
      if [traefik_log][RequestPath] {
        mutate {
          add_field => { "http_path" => "%{[traefik_log][RequestPath]}" }
        }
      }
      
      if [traefik_log][DownstreamStatus] {
        mutate {
          add_field => { "http_status" => "%{[traefik_log][DownstreamStatus]}" }
        }
        
        # Add status category tags
        if [http_status] =~ /^2/ {
          mutate { add_tag => [ "success" ] }
        } else if [http_status] =~ /^4/ {
          mutate { add_tag => [ "client_error" ] }
        } else if [http_status] =~ /^5/ {
          mutate { add_tag => [ "server_error" ] }
        }
      }
      
      if [traefik_log][Duration] {
        mutate {
          add_field => { "response_time_ms" => "%{[traefik_log][Duration]}" }
        }
        
        # Convert duration to numeric (remove 'ms' suffix)
        mutate {
          gsub => [ "response_time_ms", "ms", "" ]
        }
        
        mutate {
          convert => { "response_time_ms" => "float" }
        }
      }
      
      if [traefik_log][RequestContentSize] {
        mutate {
          add_field => { "request_size_bytes" => "%{[traefik_log][RequestContentSize]}" }
          convert => { "request_size_bytes" => "integer" }
        }
      }
      
      if [traefik_log][DownstreamContentSize] {
        mutate {
          add_field => { "response_size_bytes" => "%{[traefik_log][DownstreamContentSize]}" }
          convert => { "response_size_bytes" => "integer" }
        }
      }
      
      # Parse timestamp
      if [traefik_log][time] {
        date {
          match => [ "[traefik_log][time]", "ISO8601" ]
        }
      }
    }
  }

  # Parse Worker logs
  if [fields][service] == "rendiff-worker" {
    mutate {
      add_field => { "[@metadata][index_prefix]" => "rendiff-worker" }
    }
    
    # Extract job processing information
    if [message] =~ /Job.*processing/ {
      grok {
        match => { "message" => "Job (?<job_id>[a-f0-9-]+) %{WORD:job_action}" }
      }
      
      mutate {
        add_tag => [ "job_processing" ]
      }
    }
    
    # Extract error information
    if [message] =~ /ERROR|CRITICAL|Failed/ {
      mutate {
        add_tag => [ "error" ]
      }
    }
  }

  # Parse Database logs (PostgreSQL)
  if [fields][service] == "postgres" {
    mutate {
      add_field => { "[@metadata][index_prefix]" => "rendiff-postgres" }
    }
    
    # Parse PostgreSQL log format
    grok {
      match => { 
        "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{NUMBER:pid}\] %{WORD:log_level}:  %{GREEDYDATA:log_message}"
      }
    }
    
    # Extract slow query information
    if [log_message] =~ /slow/ {
      mutate {
        add_tag => [ "slow_query" ]
      }
    }
    
    # Extract connection information
    if [log_message] =~ /connection/ {
      mutate {
        add_tag => [ "connection" ]
      }
    }
  }

  # Parse Redis logs
  if [fields][service] == "redis" {
    mutate {
      add_field => { "[@metadata][index_prefix]" => "rendiff-redis" }
    }
    
    # Parse Redis log format
    grok {
      match => { 
        "message" => "^%{NUMBER:pid}:%{CHAR:role} %{TIMESTAMP_ISO8601:timestamp} %{CHAR:log_level} %{GREEDYDATA:log_message}"
      }
    }
  }

  # Add common fields for all logs
  mutate {
    add_field => { "environment" => "${ENVIRONMENT:production}" }
    add_field => { "service_version" => "${SERVICE_VERSION:latest}" }
  }

  # GeoIP enrichment for client IPs (if available)
  if [client_ip_clean] and [client_ip_clean] !~ /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.|127\.)/ {
    geoip {
      source => "client_ip_clean"
      target => "geoip"
      add_tag => [ "geoip" ]
    }
  }

  # User agent parsing (if available)
  if [traefik_log][RequestUserAgent] {
    useragent {
      source => "[traefik_log][RequestUserAgent]"
      target => "user_agent"
    }
  }

  # Security analysis
  if [http_path] {
    # Detect potential security threats
    if [http_path] =~ /(\.\.\/|\/etc\/|\/proc\/|admin|login|password)/ {
      mutate {
        add_tag => [ "security_alert" ]
      }
    }
    
    # Detect API abuse patterns
    if [http_path] =~ /\/api\// and [http_status] =~ /^4/ {
      mutate {
        add_tag => [ "api_abuse" ]
      }
    }
  }

  # Performance analysis
  if [response_time_ms] {
    if [response_time_ms] > 5000 {
      mutate {
        add_tag => [ "slow_response" ]
      }
    } else if [response_time_ms] > 1000 {
      mutate {
        add_tag => [ "medium_response" ]
      }
    }
  }

  # Clean up temporary fields
  mutate {
    remove_field => [ "message" ]
  }
}

output {
  # Output to Elasticsearch with dynamic index naming
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "%{[@metadata][index_prefix]}-%{+YYYY.MM.dd}"
    template_name => "rendiff"
    template_pattern => "rendiff-*"
    template => "/usr/share/logstash/templates/rendiff-template.json"
    template_overwrite => true
  }

  # Debug output (comment out in production)
  # stdout { codec => rubydebug }
}